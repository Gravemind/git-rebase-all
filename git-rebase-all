#!/bin/bash

USAGE='[-i | --interactive] <new-upstream> <root>'
OPTIONS_KEEPDASHDASH=
OPTIONS_SPEC="\
git rebase-all $USAGE
git rebase-all --continue | --abort | --skip
--
 Actions:
i,interactive!  interactive
continue!       continue
abort!          abort and check out the original branch
skip!           skip current patch and continue
"

. "$(git --exec-path)/git-sh-setup"
require_work_tree_exists
cd_to_toplevel

[[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || set -x

interactive=0

total_argc=$#
while test $# != 0
do
  case "$1" in
  --continue|--skip|--abort)
    test $total_argc -eq 2 || usage
    action=${1##--}
    ;;
  --onto)
    test 2 -le "$#" || usage
    onto="$2"
    shift
    ;;
  -i|--interactive)
    interactive=1
    ;;
  --)
    shift
    break
    ;;
  esac
  shift
done
test $# -eq 2 || [ x$action != x ] || usage

_git-rebase-all_octopus_merge() {
  [[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || set -x
  local branches="$*"

  # Use the tree from the common ancestor of all the branches. It probably
  # doesn't matter what tree we use, but the merge-base is a) conveniently
  # accessible and b) probably the most sensible thing. Conceptually, this
  # equates to committing an octomerge that undoes everything the topic branches
  # did, which is a well-defined operation.
  local merge_base=$(git merge-base $branches)
  local tree=$(git cat-file commit $merge_base | head -n1 | cut -c6-)

  # Create the octomerge: a temporary commit that has all the topic branches as
  # parents.
  local octomerge=$(echo 'git-rebase-all-merging' $branches |
                      git commit-tree $tree -p `echo $branches | sed -e's/ / -p /g'`)
  echo "$octomerge"
}
# Make function available for rebase and rebase --continue
export -f _git-rebase-all_octopus_merge

if [ $# -eq 2 ]; then
  [ x$action != x ] && usage
  # Do setup
  new_upstream=$1
  root=$2

  # Fetch all the branches that contain the root of the subtree
  branches=$(git for-each-ref --contains $root --no-merged $new_upstream --format='%(refname:strip=2)' refs/heads/ |
               grep -vxF $root)

  echo rebasing $branches onto $new_upstream

  octomerge=$(_git-rebase-all_octopus_merge $branches)
  git update-ref refs/hidden/octomerge $octomerge || die "couldn't branch"

  # git-rebase will replay merges with "recusrive" strategy, which makes our
  # "octomerge" replay fail if branches cannot be merged.
  #
  # But since git v2.22, with --rebase-merges, we can edit the interactive
  # rebase todo list to replace the default (recusrive) merge by the magic
  # octopus merge again.
  export _GIT_REBASE_ALL_OCTOMERGE=$octomerge
  export _GIT_REBASE_ALL_INTERACTIVE=$interactive
  export _GIT_REBASE_ALL_EDITOR="$(git var GIT_EDITOR)"
  _git-rebase-all_editor() {
    [[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || set -x
    local file="$1"

    # shorten hash
    local octomerge=$(git rev-parse --short $_GIT_REBASE_ALL_OCTOMERGE)

    # Read git-rebase todo list to find the octomerge, and replace it by an exec
    # of the full non-conflicting octomerge command.
    perl -i -pe '
      s|^merge -C '$octomerge'[a-z0-9]* (.*)\s*#.*|
        # The default merge merges with HEAD, our octopus_merge needs it explicitly
        $refs = "HEAD";
        # Transform "label"s to their true ref name
        $refs .= " refs/rewritten/" . join(" refs/rewritten/", split(/\s+/, $1));
        "\n"
        . "# BEGIN git-rebase-all patch\n"
        . "# Original recursive merge:\n"
        . "#" . $_ . ""
        . "# New non-conflicting merge:\n"
        . "exec git checkout -q --detach \"\$( _git-rebase-all_octopus_merge " . $refs . " )\"\n"
        . "# END git-rebase-all patch\n"
      |e' "$file"

    [[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || cat "$file"

    if [[ "${_GIT_REBASE_ALL_INTERACTIVE}" -eq 1 ]]; then
      bash -c "$_GIT_REBASE_ALL_EDITOR "'$@' -- "$file"
    fi
  }

  # The money shot: rebase the octomerge onto the new upstream.
  export -f _git-rebase-all_editor
  GIT_EDITOR="bash -c '_git-rebase-all_editor \$@' --" \
            git rebase --rebase-merges --interactive $root refs/hidden/octomerge --onto $new_upstream ||
    exit $? # if the rebase drops to shell, stop here.
else
  [ x$action = x ] && usage
  # Pass the action through to git-rebase.
  git rebase --$action ||
    exit $? # if it drops to shell again, stop again.
  branches=`git log --format=%s refs/hidden/octomerge -1`
  branches=${branches#git-rebase-all-merging }
fi

git update-ref refs/hidden/octomerge_rebased HEAD || die "update-ref failed"

echo
echo "Old branches tips:"
git rev-parse refs/hidden/octomerge^@ | xargs -n1 git --no-pager log -1 --oneline --decorate
echo
echo "New rebased branches tips:"
git rev-parse refs/hidden/octomerge_rebased^@ | xargs -n1 git --no-pager log -1 --oneline --decorate
echo

# Move all the old branches to point to the rebased commits.
# The parents of the octomerge remain in the same order through the rebase.
branches_list=($branches)
new_commit_list=(`git rev-parse refs/hidden/octomerge_rebased^@`)
if [[ "${#branches_list[@]}" -ne "${#new_commit_list[@]}" ]]; then
  die "rebased merge has been corrupted. aborting."
fi
for index in ${!branches_list[@]}; do
  branch=${branches_list[$index]}
  echo "moving $branch (was $(git rev-parse --short $branch))"
  git branch -f $branch ${new_commit_list[$index]}
done

# and clean up.
git checkout -q ${branches_list[0]}
git update-ref -d refs/hidden/octomerge
git update-ref -d refs/hidden/octomerge_rebased
