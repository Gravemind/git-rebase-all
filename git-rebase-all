#!/bin/bash

USAGE='[-i | --interactive] <new-upstream> <root>'
OPTIONS_KEEPDASHDASH=
OPTIONS_SPEC="\
git rebase-all $USAGE
git rebase-all --continue | --abort | --skip
--
 Actions:
i,interactive!  interactive
continue!       continue
abort!          abort and check out the original branch
skip!           skip current patch and continue
"

. "$(git --exec-path)/git-sh-setup"
require_work_tree_exists
cd_to_toplevel

[[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || set -x

interactive=0

total_argc=$#
while test $# != 0
do
  case "$1" in
  --continue|--skip|--abort)
    test $total_argc -eq 2 || usage
    action=${1##--}
    ;;
  --onto)
    test 2 -le "$#" || usage
    onto="$2"
    shift
    ;;
  -i|--interactive)
    interactive=1
    ;;
  --)
    shift
    break
    ;;
  esac
  shift
done
test $# -eq 2 || [ x$action != x ] || usage

_git-rebase-all_octopus_merge() {
  [[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || set -x
  local branches="$*"

  # Git already ignores "duplicated parents" (two branch on same commit), but
  # with a warning. ! we must not sort !
  local tips=$(git rev-parse $branches | awk '!a[$0]++')

  # Use the tree from the common ancestor of all the branches. It probably
  # doesn't matter what tree we use, but the merge-base is a) conveniently
  # accessible and b) probably the most sensible thing. Conceptually, this
  # equates to committing an octomerge that undoes everything the topic branches
  # did, which is a well-defined operation.
  local merge_base=$(git merge-base $branches)
  local tree=$(git cat-file commit $merge_base | head -n1 | cut -c6-)

  # Create the octomerge: a temporary commit that has all the topic branches as
  # parents.
  local octomerge=$(echo 'git-rebase-all-merging' $branches |
                      git commit-tree $tree -p `echo $tips | sed -e's/ / -p /g'`)
  echo "$octomerge"
}
# Make function available for rebase and rebase --continue
export -f _git-rebase-all_octopus_merge

if [ $# -eq 2 ]; then
  [ x$action != x ] && usage

  remember="
Remember to use 'git rebase-all' instead of 'git rebase' for:

  git rebase-all --continue
  git rebase-all --skip
  git rebase-all --abort

"
  echo -n "$remember"

  # Do setup
  new_upstream=$1
  root=$2

  # Fetch all the branches that contain the root of the subtree
  branches=$(git for-each-ref --contains $root --no-merged $new_upstream --format='%(refname:strip=2)' refs/heads/ |
               grep -vxF $root)

  echo rebasing $branches onto $new_upstream

  octomerge=$(_git-rebase-all_octopus_merge $branches)
  git update-ref refs/hidden/octomerge $octomerge || die "couldn't branch"

  # git-rebase will replay merges with "recusrive" strategy, which makes our
  # "octomerge" replay fail if branches cannot be merged.
  #
  # But since git v2.22, with --rebase-merges, we can edit the interactive
  # rebase todo list to replace the default (recusrive) merge by the magic
  # octopus merge again.
  export _GIT_REBASE_ALL_OCTOMERGE=$octomerge
  export _GIT_REBASE_ALL_INTERACTIVE=$interactive
  export _GIT_REBASE_ALL_EDITOR="$(git var GIT_EDITOR)"
  _git-rebase-all_editor() {
    [[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || set -x
    local file="$1"

    # shorten hash
    local octomerge=$(git rev-parse --short $_GIT_REBASE_ALL_OCTOMERGE)

    # Read git-rebase todo list to find the octomerge, and replace it by an exec
    # of the full non-conflicting octomerge command.
    perl -i -pe '
      s|^merge -C '$octomerge'[a-z0-9]* (.*)\s*#.*|
        # The default merge merges with HEAD, our octopus_merge needs it explicitly
        $refs = "HEAD";
        # Transform "label"s to their true ref name
        $refs .= " refs/rewritten/" . join(" refs/rewritten/", split(/\s+/, $1));
        "\n"
        . "# BEGIN git-rebase-all patch\n"
        . "# Original recursive merge:\n"
        . "#" . $_ . ""
        . "# New non-conflicting merge:\n"
        . "exec git checkout -q --detach \"\$( _git-rebase-all_octopus_merge " . $refs . " )\"\n"
        . "# END git-rebase-all patch\n"
      |e' "$file"

    [[ "${GIT_REBASE_ALL_DEBUG:-0}" -eq 0 ]] || cat "$file"

    if [[ "${_GIT_REBASE_ALL_INTERACTIVE}" -eq 1 ]]; then
      bash -c "$_GIT_REBASE_ALL_EDITOR "'$@' -- "$file"
    fi
  }

  # The money shot: rebase the octomerge onto the new upstream.
  export -f _git-rebase-all_editor
  GIT_EDITOR="bash -c '_git-rebase-all_editor \$@' --" \
            git rebase --rebase-merges --interactive $root refs/hidden/octomerge --onto $new_upstream || {
    # if the rebase drops to shell, stop here.
    r=$?
    echo -n "$remember"
    exit $r
  }
else
  [ x$action = x ] && usage
  # Pass the action through to git-rebase.
  git rebase --$action ||
    exit $? # if it drops to shell again, stop again.
  branches=`git log --format=%s refs/hidden/octomerge -1`
  branches=${branches#git-rebase-all-merging }
fi

git update-ref refs/hidden/octomerge_rebased HEAD || die "update-ref failed"

# The parents of the octomerge remain in the same order through the rebase.
old_tips=($(git rev-parse refs/hidden/octomerge^@))
new_tips=($(git rev-parse refs/hidden/octomerge_rebased^@))
if [[ "${#old_tips[@]}" -ne "${#new_tips[@]}" ]]; then
  die "rebased merge has been corrupted. aborting."
fi

git_pretty_tips() { for tip in "$@" ; do git --no-pager log -1 --oneline --decorate --color=always "$tip" ; done ; }
echo "
Old branches tips:
$(git_pretty_tips "${old_tips[@]}")

New rebased branches tips:
$(git_pretty_tips "${new_tips[@]}")
"

git_log_small() { git log --abbrev=6 --format='%h %<(80,trunc)%s' "$@" ; }

apply=()
revert=()
had_warnings=0
for i in ${!old_tips[@]}; do
  old_sha="${old_tips[$i]}"
  new_sha="${new_tips[$i]}"

  old_msg="$(git log --format='%s' -1 $old_sha)"
  new_msg="$(git log --format='%s' -1 $new_sha)"
  if [[ "$old_msg" != "$new_msg" ]]; then
    echo "warning: old and rebased commit message does not match: ($old_sha) '$old_msg' ($new_sha) '$new_msg'" >&2
    had_warning=1
  fi

  for branch in $(git for-each-ref --points-at=$old_sha --format='%(refname:strip=2)' refs/heads/ | \
                    grep --fixed-string --line-regexp -f <(printf '%s\n' $branches) )
  do
    apply+=("git branch -f $branch $new_sha")
    revert+=("git branch -f $branch $old_sha")
  done
done

echo "
Note: You can REVERT with those commands:

$(printf ' %s\n' "${revert[@]}")
"

echo "Now applying:
"
for app in "${apply[@]}" ; do
  echo " $app"
  eval "$app" || die "branch failed, see above to revert"
done
echo

# and clean up.
git checkout -q ${branches%% *}
git update-ref -d refs/hidden/octomerge
git update-ref -d refs/hidden/octomerge_rebased
